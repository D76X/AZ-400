----------------------------------------------------------------

Microsoft AZ-400 Exam Actual Questions
The questions for AZ-400 were last updated on Oct. 2, 2023.
Viewing page 1 out of 47 pages.
Viewing questions 1-10 out of 472 questions

https://www.examtopics.com/exams/microsoft/az-400/view/

----------------------------------------------------------------

-------------------------------------------------------------------------
PT0X-Q0X: 
question text..
Which of the following is the option you would choose?

A0X-1: 
A0X-2: 
A0X-3: 
A0X-4: 

MY ANSWER TO PT0X-Q0X
--------------------------------------------------------------------------
?
--------------------------------------------------------------------------

CORRECT ANSWER TO PT0X-Q0X
--------------------------------------------------------------------------
?
--------------------------------------------------------------------------

-------------------------------------------------------------------------
PT00-Q0X: 

?

A04-1: 
A04-2: 
A04-3: 
A04-4: 

MY ANSWER TO PT00-Q04
--------------------------------------------------------------------------
?
--------------------------------------------------------------------------

CORRECT ANSWER TO PT00-Q04
--------------------------------------------------------------------------
?
--------------------------------------------------------------------------

REFS:


-------------------------------------------------------------------------
PT00-Q04: 

You are developing the security validation plan for an application’s lifecycle.
For which activity should you include a passive penetration test?

 - continuous deployment
 - continuous integration
 - IDE/pull requests
 - nightly test runs

MY ANSWER TO PT00-Q04
--------------------------------------------------------------------------
?
--------------------------------------------------------------------------

CORRECT ANSWER TO PT00-Q04: continuous deployment
--------------------------------------------------------------------------


--------------------------------------------------------------------------

REFS:
Continuous deployment should include passive penetration tests as well as SSL and infrastructure scans. Nightly test runs should include infrastructure scans and active penetration tests. Continuous integration should include an Open-Source Software (OSS) vulnerability scan. The integrated development environment/pull request step should include static code analysis and code reviews.

Explore key validation points - Training | Microsoft Learn
https://learn.microsoft.com/en-gb/training/modules/introduction-to-secure-devops/5-explore-key-validation-points?pivots=bash


Control releases with deployment gates - Azure Pipelines | Microsoft Learn
https://learn.microsoft.com/en-gb/azure/devops/pipelines/release/approvals/gates?view=azure-devops

-------------------------------------------------------------------------
PT00-Q03: 

https://learn.microsoft.com/en-gb/credentials/certifications/exams/az-400/practice/assessment?assessment-type=practice&assessmentId=56

You are developing a security validation plan for an application’s lifecycle.
For which activity should you include an 
automated Open-Source Software (OSS) vulnerability scan?

A03-1: continuous deployment
A03-2: continuous integration
A03-3: IDE/pull requests
A03-4: nightly test runs

MY ANSWER TO PT00-Q03
--------------------------------------------------------------------------
continuous integration
--------------------------------------------------------------------------

CORRECT ANSWER TO PT00-Q03
--------------------------------------------------------------------------
continuous integration
--------------------------------------------------------------------------

REFS:

--------------------------------------------------------------------
Continuous integration 
should include an OSS vulnerability scan. 
--------------------------------------------------------------------
The integrated development environment / pull request step 
should include 
static code analysis and code reviews. 
--------------------------------------------------------------------
Nightly test runs 
should include 
an infrastructure scan. 
--------------------------------------------------------------------
Continuous deployment 
should include 
passive penetration tests, an SSL scan, and an infrastructure scan.
--------------------------------------------------------------------

AZ-400: Implement security and validate code bases for compliance  Introduction to Secure DevOps 

Explore key validation points - Training | Microsoft Learn
https://learn.microsoft.com/en-gb/training/modules/introduction-to-secure-devops/5-explore-key-validation-points?pivots=bash


Continuous security validation should be added at each step from development 
through production to help ensure the application is always secure.
This approach aims to switch the conversation with the security team
from approving each release to consenting to the CI/CD process and monitor 
and audit the process at any time.

-------------------
IDE / pull request
-------------------
Validation in the CI/CD begins before the developer commits their code.
** Static code analysis tools in the IDE ** provide the first line of 
defense to help ensure that security vulnerabilities aren't introduced 
into the CI/CD process.

In ** Azure DevOps Enabling branch policies ** on the shared branch requires 
a ** pull request ** to start the merge process and ensure the execution of 
all defined controls.

The pull request should require a ** code review **, the one manual but 
important check for identifying new issues introduced into your code.

Along with **this manual check **, commits should be linked to **work items** 
for auditing why the code change was made and require a continuous integration (CI) 
build process to succeed before the push can be completed.

---------------------------------------
Explore continuous security validation
https://learn.microsoft.com/en-gb/training/modules/introduction-to-secure-devops/6-explore-continuous-security-validation?pivots=bash
---------------------------------------
developers don't hesitate to use components available in public package sources 
(such as npm or NuGet).
as the dependency on these third-party OSS components increases, the risk of security
vulnerabilities or hidden license requirements also increases compliance issues.
For a business, it's critical, as issues related to compliance, liabilities, and 
customer personal data can cause many privacy and security concerns.

Many tools can scan for these vulnerabilities within 
the build and release pipelines.
**
Once the merge is complete, the CI build should execute as part of the pull request (PR-CI) process.
These CI builds should run static code analysis tests to ensure that the code 
follows all rules for both maintenance and security.
**

----------------------
STATIC CODE ANALYSIS
----------------------
Many of the tools seamlessly integrate into the Azure Pipelines build process. 

-1 SonarQube.
-2 Visual Studio Code Analysis and the Roslyn Security Analyzers.
-3 Checkmarx - A Static Application Security Testing (SAST) tool.
-4 BinSkim - A binary static analysis tool that provides security and correctness results for Windows portable executables and many more.

----------------------
3rd Party Packages Vulnerability scanner
&
OSS licenses
----------------------

Organizations try to manage third-party packages vulnerabilities or OSS licenses. 
** Mend Software's tools** can make this identification process almost instantaneous.

-----------------------------
Understand threat modeling
https://learn.microsoft.com/en-gb/training/modules/introduction-to-secure-devops/7-understand-threat-modeling?pivots=bash
-----------------------------
Microsoft Security Development Lifecycle (SDL)
Threat modeling is a core element of the Microsoft Security Development Lifecycle (SDL).
https://learn.microsoft.com/en-us/compliance/assurance/assurance-microsoft-security-development-lifecycle
-----------------------------

It's an engineering technique you can use to help you identify threats, attacks, vulnerabilities, 
and countermeasures that could affect your application.
It is used to REDUCE RISK With non-security experts in mind.
The tool makes threat modeling easier for all developers by providing clear guidance on creating
and analyzing threat models. 
iT MAKES IT easier for all developers through a **standard notation** 
for ** visualizing **:
-------------------------------------------------------
- system components
- data flows
- security boundaries.
-------------------------------------------------------

Helps threat modelers identify classes of threats they should consider based 
on the structure of their software design.

-----------------------------------------------------------------------
The Threat Modeling Tool enables any developer or software architect to:
-----------------------------------------------------------------------

-1 Communicate about the security design of their systems.
-2 Analyze those designs for potential security issues using a proven methodology.
-3 Suggest and manage mitigation for security issues.

-------------------------------------------
There are five major threat modeling steps:
https://learn.microsoft.com/en-us/azure/security/develop/threat-modeling-tool
Exercise threat modeling
https://learn.microsoft.com/en-gb/training/modules/introduction-to-secure-devops/8-exercise-threat-modeling?pivots=bash
-------------------------------------------

-1 Defining security requirements.
-2 Creating an application diagram.
-3 Identifying threats.
-4 Mitigating threats.
-5 Validating that threats have been mitigated.

---------------------------------------------------------
Review code coverage - Azure Pipelines | Microsoft Learn
https://learn.microsoft.com/en-gb/azure/devops/pipelines/test/review-code-coverage-results?view=azure-devops#artifacts
---------------------------------------------------------

-------------------------------------------------------------------------
PT00-Q02: 


You need to implement a Git hook that will be triggered automatically in 
response to a Git commit being run on a Windows server.

To what should you set the first line of the predefined Git hook script 
so that you can execute the script?

A. #!/bin/sh
B. #!\bin\sh
C. #!C:/Program\ Files/Git/usr/bin/sh.exe
D. #!C:\Program Files\Git\usr\bin\sh.exe

MY ANSWER:
--------------------------------------------------------------------------
 
--------------------------------------------------------------------------

CORRECT ANSWER: C: #!C:/Program\ Files/Git/usr/bin/sh.exe

--------------------------------------------------------------------------

To execute any of the predefined Git hook scripts, the existing line of 
#!/bin/sh 

needs to be replaced with the one pointing to the location of the Bash 
script interpreter. The notation must use the forward slashes and an escape
 character to account for the space character in the path.

Implement Git hooks - Training | Microsoft Learn
https://learn.microsoft.com/en-gb/training/modules/explore-git-hooks/3-implement

Service hooks events - Azure DevOps | Microsoft Learn
https://learn.microsoft.com/en-gb/azure/devops/service-hooks/events?view=azure-devops

--------------------------------------------------------------------------

REFS:

https://learn.microsoft.com/en-us/training/modules/explore-git-hooks/

Git hooks are a mechanism that allows code to be run before or after certain
Git lifecycle events. For example, one could hook into the commit-msg event 
to validate that the commit message structure follows the recommended format.

The hooks can be any executable code, including shell, PowerShell, Python, 
or other scripts. 
Or they may be a binary executable. 
Anything goes!

The only criteria are that hooks must be stored in the .git/hooks folder in 
the repo root. 
Also, they must be named to match the related events (Git 2.x):

applypatch-msg
pre-applypatch
post-applypatch
pre-commit
prepare-commit-msg
commit-msg
post-commit
pre-rebase
post-checkout
post-merge
pre-receive
update
post-receive
post-update
pre-auto-gc
post-rewrite
pre-push

you can use hooks to:

-1 enforce policies
-2 ensure consistency 
-3 control your environment:

Examples:

-1 Enforcing preconditions for merging
-2 Verifying work Item ID association in your commit message
-3 Preventing you & your team from committing faulty code
-4 Sending notifications to your team's chat room (Teams, Slack, HipChat, etc.)

----------------------
Implement Git hooks
https://learn.microsoft.com/en-us/training/modules/explore-git-hooks/3-implement
----------------------

------------------------------------
Client-Side Git Hooks on Windows.
------------------------------------

Git ships with several sample hook scripts in the repo .git\hooks directory. 

If you open that folder, you'll find a file called 
 ** pre-commit.sample ** 
To enable it, rename it to 
** pre-commit ** 
by removing the .sample extension 
and making the script executable.

The script is found and executed when you attempt to commit using git commit.
You commit successfully if your pre-commit script exits with a 0 (zero). 

**************************************************************
If you're using Windows, simply renaming the file won't work.
**************************************************************
Git will fail to find the shell in the chosen path specified in the script.
The problem is lurking in the first line of the script, 
the shebang declaration:
-----------
#!/bin/sh
-----------

On Unix-like OSs, the SheBang: #! 

Tells the program loader that it's a script to be interpreted, and /bin/sh 
is the path to the interpreter you want to use, sh in this case.

---------------------------------
Windows isn't a Unix-like OS. 
---------------------------------

Git for Windows supports Bash commands and shell scripts via ** Cygwin **.

Fix it by providing the path to the sh executable on your system. 
It's using the 64-bit version of Git for Windows, so the baseline looks like this:

------------------------------------------
#!C:/Program\ Files/Git/usr/bin/sh.exe
------------------------------------------

```
#!C:/Program\ Files/Git/usr/bin/sh.exe
matches=$(git diff-index --patch HEAD | grep '^+' | grep -Pi 'password|keyword2|keyword3')
if [ ! -z "$matches" ]
then
    cat <<\EOT
Error: Words from the blocked list were present in the diff:
EOT
    echo $matches
    exit 1
fi
```

The repo ** .git\hooks ** folder isn't committed into source control. 
You may wonder how you share the goodness of the automated scripts you create with the team.
The good news is that, from Git version 2.9, you can now map Git hooks to a folder that 
can be committed into source control.

You could do that by updating the global settings configuration for your Git repository:
-------------------------------------------------------
Git config --global core.hooksPath '~/.githooks'
-------------------------------------------------------

----------------------------------------------
Server-side service hooks with Azure Repos
https://learn.microsoft.com/en-us/azure/devops/service-hooks/events?view=azure-devops
----------------------------------------------

So far, we've looked at the client-side Git Hooks on Windows. 
Azure Repos also exposes server-side hooks. 
Azure DevOps uses the exact mechanism itself to create Pull requests. 
You can read more about it at the Server hooks event reference.


-------------------------------------------------------------------------
PT00-Q01: 

You need to minimize the response time when using Azure DevOps Git-based 
repositories that contain large files.

Which Git extension should you use?

A. Git LFS
B. Git Machete
C. GitFlow
D. GitX

MY ANSWER:
--------------------------------------------------------------------------
A00-1: Git LFS
--------------------------------------------------------------------------

CORRECT ANSWER:
--------------------------------------------------------------------------
A00-1: Git LFS

-1 Git LFS 
is a Git extension that provides the fastest response time when using 
Azure DevOps Git-based repositories that contain large files. 

-2 GitFlow 
is a Git extension that implements the GitFlow branching model. 

-3 Git Machete 
is a Git extension that simplifies and automates repository organization.

-4 GitX 
is a Git extension that provides an improved development workflow.
--------------------------------------------------------------------------

REFS:
Learn  Training  Browse  AZ-400: Development for enterprise DevOps  Manage Git repositories 
Work with large repositories
https://learn.microsoft.com/en-gb/training/modules/manage-git-repositories/2-work-large-repositories

Why repositories become large?
There are two primary causes for large repositories:

-1 Long history
-2 Large binary files
-3 You can also reduce clones by filtering branches or cloning only a single branch.

--------------
Shallow clone
--------------

If developers don't need all the available history in their local repositories, a good option is 
to implement a shallow clone. It saves both space on local development systems and the time it 
takes to sync.

-------------------------------------
git clone --depth [depth] [clone-url]
-------------------------------------



------------
VFS for Git
https://github.com/microsoft/VFSForGit
VFS stands for Virtual File System. 
------------

VFS for Git helps with large repositories. It requires a Git LFS client.
VFS for Git virtualizes the file system beneath your Git repository so that Git and all tools
see what appears to be a regular working directory, but VFS for Git only downloads objects as 
they are needed.

Typical Git commands are unaffected, but the Git LFS works with the standard filesystem to 
download necessary files in the background when you need files from the server.

---------
Scalar
Introducing Scalar: Git at scale for everyone
https://devblogs.microsoft.com/devops/introducing-scalar/
---------

Scalar is a .NET Core application available for Windows and macOS. 
With tools and extensions for Git to allow very large repositories to maximize 
your Git command performance.

By default each Git repository has a copy of all files in the entire history.

It achieves by enabling some advanced Git features, such as:

- Partial clone: 
reduces time to get a working repository by not downloading all Git objects right away.

-Background prefetch: 
downloads Git object data from all remotes every hour, reducing the time for foreground git fetch calls.

-Sparse-checkout: limits the size of your working directory.

-File system monitor: 
tracks the recently modified files and eliminates the need for Git to scan the entire work tree.

-Commit-graph: 
accelerates commit walks and reachability calculations, speeding up commands like git log.

-Multi-pack-index: enables fast object lookups across many pack files.

-Incremental repack: 
Repacks the packed Git data into fewer pack files without disrupting concurrent commands using the multi-pack-index.

--------------------------------------------------------------------------